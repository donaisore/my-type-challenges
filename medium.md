## Answers
### [Get Return Type](https://github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBBMELQQOIFMAuEBKaCuAnAdhACoCeADspPHDbVQEYkQCC+qAFgPb5MBi2EABQABAIZsAZtgCUEAMSBaOUBYvvICW+Cclzz62VQBtUcdWCpzzEQFcxgeVVTUQCK+gfwZAPfGPAdgyBo9UBnDIB+GQGMMgMUMgFcMgQAGWKh4+KQUADxEAHyhgEkMgP7ygBSugNoMgFoMgIAMoUShboDcRoBRDIAkCp7JgGvKgOn6gJoMgNEMHsmA+dqAoxGA6gyAfgz1gEAMdhCA0fKAEgyADgyDoVOoAM5UAMbcM+gShAC8QgBuAFwQ9Jyc+sjismsJEADeVFCqElvS11AQuDgEEACMj8j6M5RPTy9Im9oFQAL6DVDkZAQUQQDYAWRIESiMWQsUhFE4d1W52AwAgMy42H0ABM9tCAETvCAAHxgFKoU1Cg3OiFUqAAEth6IBzBkAXR6AWKimoAsf-YqFQZBm2zxs3m7AAdAArGbyzi4ADmwGgwEVojAIGAplAEAA+mbzRbzRBAMoM1sA1gyAZoYfIBJhmSgAwowCmiqbLT6TRADaYMdDEciCKj4ucNkQIMgAB6oZD4EkzITytOiDVSmE8U7ndSabQYCAAfkwEF2+GQmy0AG4jSBvb6LRA-IBOhkAEwyARoYfK3G02zf7DaoALZkNXoIOXCAAUQAjthRPoADQz2MUeboUEQCS4TjDiAAcmEQbgcsXR3w6uQM2A2FQBhmB8DUIg81EvxTGwA2lRp2vkBusRzgu+ixMsuDqOqK4hq80RQrEgi5gSqAQZeCToUuv7-oBwGLrE7zQAAzNBSKweGiFwucBGEehCSYVAf7rqgQHznhADCe5kEcsYAPL0IqAGoCRoZwXEFFnBAHGjtxfECRutH0auTEsSBsQAAq7sOqi-LE+yHMc+B0RAMFAqJaLiecGl7tpaJ6Uc4i0XRWHKbhoEWYeEgHAewlkfB7nuQenmcAeCnOYJKl4dSdLQD5pnhkGWLboZGFhThrGgVFMCxSi8EJdi+DvKFAC6z4UJJnEyfxglwpcVCiLsX4ESugVeSVUD0BmuwHuw3z6MFVBkC8myIRW2DDvQWhgOCYCLPgyxJTVgg7HsBz2fgSGbCWHzljAM1LCsBWLctdkGSuADuuziCQG1bdSuwgmAxr9s2gCE1m4rZ+IAwwyAOsMfb9oOj3gFA5yAMeRgAq3skgCOioAkOYimKEpSjKMxykqKpqpq2riDMZ1aDqerAxA4PJIA0ZGNKK4qStKwCygqyqqhqWrADMhx3qoSxUOcgC6DG4gBrcm4gBNUYAMhnkwjVM06j9Oarq+qGkAA)

- infer での型推論を ConditionalType に組み込むことで、返り値の型を得ることができる。

### [Omit](https://github.com/type-challenges/type-challenges/blob/main/questions/00003-medium-omit/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBDMELQQPIFsCWAXS8491gRgJ4QCCAdugBYD2ZxAYgK4QAUAAgIYUBmjAlBADEgWjlAWL5DGZVLSH5GqADbo4qMmCyDNEQFcxgeVV1UQCK+gfwZAPfHHAdgyBo9UBnDIB+GQGMMgYoZAVwzOABigwAeACoAaCABpAD53QCSGQH95QApXQG0GQC0GQEAGd193C0B1hkBbhkBFhmdAaQZASIZ3IIjAKSVAEzTATQZAaIYrcMB87UBRiMB1BkA-BkrAIAYDCEBo+UAJBkAHBm73EfQAZyxVdABTACduDgBjaYhfagATaggAbywodAwFaYAuCDH0WdUAcz2IdemxxcuABwPaU-PLshuoKEXqZDPI4zdanfDUahHLhYAC+3XQhGeKzWmwACrNpgA3VDTADuEAAvBAALKELzoPwbaiBADk90eLzeZBpEAAPhAaQd0EcaSFuv8yOcIOgqacUdR0VicfiibtfhB-oDgdNQRAFgoxtN-LCsCN3N0QhAAOIYAASjHwgHMGQBdHoBYqJqgCx-yjodDPMbHYDAcaLSgAOgAVmNfdRZldgNBgP6OGAQMB1KAIAB9ZMp1MpiCAZQYM4BrBkAzQx2QCTDOFABhRgFNFJNpyuJiCx9QIpEksloCkBYKG2VYADaqIgqggAGtpoRqNxVhAOGMID3pgAPGZkdaToIQAD8EDIWLmEFOqIAumLu7uwHCwAmq5WIA5AJ0MgAmGQCNDHYrxXz+na6hASH0MLEStthAAKIAI6MBwCiBP+M5IosX4wmqswAhybD1tMcA+qBRzfA8wCMAcGo0nWP4KhODyEhAnZYBBUEUkBIEKN4lHTNBKoAIyBKS5KUpstL0k8qCvNIzIhEJ2pQAx0H0cBoH0ZBjEggATGxTY+OK3EPLx-G0Cy7I0oqQLTCCvLCWAR6nsAEBIWMcCzlRVmzPBsxgMhEBzPZpHsc2nHUhyPGMgJWkcqomKgag6y8uoUxzAsyyrFSOxYFyRwfBc1xYD5fFMklXw-AqAJ6SCYIQlCagnhF8xLCsYkgsxcX7IcJxnMl3xYLpyqquCkLTNCJUUJF5UATJTHrHJNXCnVmUpSeZ4vumgCE1hYV4OIAwwzpM+001nGoBYIagDHkYAKt7hIAjoqAJDmjrOq67qet6fqBsGobhsAXBjLicyRtGUA7ftgDRkdUToum6Hpeo811BiGYYRmMkI4QJEzvRAgC6DBYgBrchYgBNUYAMhm-edANXQGIN3VGMZxkAA)

- in を使って loop する
- [as による type assertion](https://typescriptbook.jp/reference/values-types-variables/type-assertion-as) を使い、key に never を当てることで無視できる

```
型アサーションとキャストの違い
型アサーションは、他の言語のキャストに似ています。キャストとは、実行時にある値の型を別の型に変換することです。型アサーションは、実行時に影響しません。値の型変換はしないのです。あくまでコンパイル時にコンパイラーに型を伝えるだけです。コンパイラーはその情報を手がかりに、コードをチェックします。型アサーションはキャストではないため、TypeScriptでは型アサーションをキャストとは呼ばないことになっています。実行時に型変換をするには、そのためのロジックを書く必要があります。
```

### [ReadOnly 2](https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBAcELQQEoFMCGATA9gOwDYE8IAmSeOci0gI0IEFsAXACx0IDEBXCACgAFVGAMw4BKCAGJAtHKAsXwkAnNFjyFxmKgCtkAYwZwA1snwBnMKXHmIgK5jA8qqmoRQCYMgOwZA0eqBUfUAOpgAMAKl8AWDF4A0l6ASQyAa8qA0QxeALL4KBg4BEQAPD4ANBBBAHxhgPnagKMRgOoMgH4MgJoMgEAMdhDBXoAyDIDgxoBZ2oCqDIAxDIBmDIAiDJGALBqAECqA9gyAgAy+Xk6STrVOgOsMgLcMgIsMgGMMgMUMToD+DKGAtVHr4YBRDIBAOoAUroDWDKWVtY2tnV2AVgxdAyOAWAmAHHpTCUoEabn+gDAqgBuWJ2GZUAngwdWaLVbbXaHU7nKqkQDR8oAJBkADgzVLyYhgmKAAS0YyDkglQWmQEB8mCwEAA3qQoAxcQxcMgAFwQIwMOT4gDmdIg6GQRi0XIADgycGyOVzsLyoFAtJgALYi5kMZDoNlUTCYZkCUgAX2qCuwHIgDEpmDZcQ+SXwqQpWEyAHIGUzkE6IAAfCBOgVC0Xi7BO7IQAC8NL5ruZbIARAAJQwx9J8v3C3Fi3ESiAxwTaqioORJvkK5Wq9Vs4m4IzIZNQQ2kc1YAB0UbJ4fjyFwuEwMYgwGAEAAonI5Jg5GytAJsJgGBAFKgjEZcdzsBBUHPFLaICLRyLCQx8A2LU3UwHM6v2-m5Gxtb3+0OR2OJ1OZxuF0uV2u359CDvMHu5API9mxLFVkDVdAwzNOQODJe8AHkglITEvGqEMAHFGTjDgqEAcwZAC6PQBYqLKSJACx-pgGAYEUjBZftsS0Jgm3UIwmzHblgGgYB1FQMAQGAUxQAgAB9ETRLE0SIEAZQZJJOQBmhkAH4ZAEmGUJAAwowBTRWE8StKEiA+NMA89wga1N2Ue1MiCCBkAADzVbB0CMCADHwTBBHJKCnJc8kQ3DWkoHnH8IAAbQABQgfFHMMTyfDXBzQus2z7KyCAAH4IFCtlsGQAA3QkAF02R8ELcrAfUIAAMgjKAQrC1cPNc6KFzSyybOQOyHIs1LMpyuQIDZYL8vJIqSoEkBNO0sSICWQBOhkACYZAEaGeSprG8aRN0-jcWVMdZwMslqQgWhcFxAxMkHKy9x0CBSsEUdFR9XgdrgBjUC7VruUFYAOAZKsnX0-BDMnasHPDQLSFO86GBSA6juQFJjMSUy0gtABGbJMhtZREawFHslR0Gzu0CGoYMWH4hM5JMcwJHnVbD1vV9QU0wzHBgxO-GdHVHHayHNnCcO4m4Z-e0LSIanGWZWmfVPdNAxZ7nwY53GoDBgnIb5mGBdtIWsBFyWGbPZmIFRuWCYV5NirAe97qMOBrPBm3HzkMAdssh2oI1hGHUp0W3Qlp18Sy57cXQYNTHxNUiRJMlPaRyqzTF1l2U5HlSClpnsGSyUk5lUhQLLDUIC1HU0GwYawDDwliVJclhdj-yt1bTPpVlfk9el88M8Tpuc6VMCIM1bVdRL+ty4jqvlfZyDfO-ev48b5O-LJwhU8DDupXniBc-A8sC4H4vS8ElaJsAQmsnCmpZAGGGGZlpWtaLfAKAQ0AY8jABVvUJAEdFQBIcxI8jKOo2jgHooxZirE5DsU4gIIwAB3QkXEeIPwgC-UIgBoyLIhRKiNE6JCiASxNiHFgBGB1J9c8OJDYQEALoMThABrck4QATVGABkMn+6D-6AKYjg0BsDeL8SAA)

- in を使って loop する
- as による type assertion(Omit と同じ)
- readonly な型と readonly でない型を作り、 `&` で組み合わせる

### [Deep Readonly](https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCcELQQCIFNkAcICVkEMAmA9gHYA2AnpPHNTZQEZkQCCRALgBbGMBiArhAAoAAjjYAzXgEoIAYkC0coCxfWQCdchUoxkE6AK2QBjVnADWyMgGdZeVGjCUZDiICuYwPKqdqICqGQGsMgDoZA5QyA9QyAEwyAdgyAmgyAngyAZgwhgIsMgJcMgIcMgD8MgP0MyYAQ-4BSDIARDIDODIC6DCGArQxe3v7BgEkMgLGKgAx6gCFugNYMgJD-lYC1UYD+DIBryoBRDIBAOoAUro1hgNEMAAYo6Nj4xOQAPAAqAHxjlYD52oCjEYDqDIB+DGGAQAzuEIDKDCGATVGAMhmA5gyA9gzlgaEdlYCORoDGDFGAIgwjgBYMgM8GgFnaWyigHkGQAGDIBVBg++0AsomAdCVAIAMgCLUwAOpvCAvFAJ0MgCsGQCWDDdAMABgDtDUaAUf1AIGRN0AQgw9HaAbQZAMkM+y2gGkGLbwwD3yoBfgKxgAU0nqADctAKAMWMAjQzJDGVQDVDIAFhmSo2O3yu8MAV4GAMCVlYBquMagERjQBkRvLvoAZBiugFkGPaHSiAaPlABIMgAcGI5jR2scyUVhkNDICAADQgAF4IABvShQAAeAC5A8GoBAcBGAIxRqB0CMAcnYAEsU1GAL5Rsip9hmLNQXOu92egCiIY9hmQeD9kejEFUMw0EHDjabzbUs0YsYgCa73db5AgyYgaczOajLfUo-zE8LZGLEFLUDdHogCwIhAbkzQ0znZDmXqWEGAwAg5k4vBI9bonvMOAAtp6cJYxlWa6w62NKI6-0oM8AHF01YAAJXg6CuQAuj0AWKjRkALH-2FYVg0HMMML2dfR2AAOh0cxcIIZQAHNgGgYAdBwMAQGAOxQAgAB9ZiWNYliTmORpAGaGZJAEmGSpAAwowBTRSYtixMYiBaLsDdPX3Q9e0WM9-SDaNZ17CAAG0AGkIHTIgIFMMgCDELcAF0I0M4yt200yIGQEMfyIPBLCIZAADdkGUCAAH5rK02yIzknsNEWGyljAUsGPEsSIEAMYYMSCMUMVE6L2Kk9NnzQYjWAgGTAwgCsAEdeBwEgABoCurAwcuzCAxGUAhnwnIQZLgHDSpIZAiBI5BzGAXhWHTEhzCzMB9GIcwcvrZTKH7ARpF9M8ACYloiuxxqISa6obea-WW1awDy7gCAIRSGwWDTLJMhZTMO8sIAAIRwLz-WO06ZKsvBwryp6AC8GzeuYPpMsRwruzd9HfXqGw0ygv2quYipKkg5iCkdjy9OMlgq+HazwLHsbhqrDER4rStRmx5JCr0luxyrvzrWnCdu8HPUxhsVJjCNdsWiAVvoCNJuUPSSMofQI05qA8AjOgTs60Qo2QCXEwgEjlaHKB2HVjWoHTCNWGUXhkBVpsdFTIWRZXIdcx14wC2QEgSAIK3oxtrsSAjWGdcnFMypNzsdefT20yLW6dezP2hzD13KFzUs8ppjmuavA2RdXCAAB98vHIheGfB8vPj+7cZ-fGOcoNS2zmhb9or4LR3HC3urr9GIHFgPhyPCBpbHOXcCIGd68YJWO6gSvRzV0fVKHiAtanptx8YPXcsN42dbHmezYnJuSJdps3aHReDPtx3nZVg-p9bj3O-Ur2NZ9yONcljWj6Dm+2w0kPl2j63H6bH-VyxzWqzem1VGZJyPv2He6cs4Bnfg3CMud86eUAWAKKqV2KAEJrEIGJYqAGGGQA6wwpQwZJOioAgIQEAMeRgAVb0qIAR0VACQ5khFCaEMJYXMDhfChFiJkQoqIcwAB3TylFqJQDPDQyogBoyJGMhVC6FMLAGwnhAiRFSLkWAOYAgJABrpgmhQoogA1uXOBcWRrCFFKK4aosiVEaJ0SAA)

ポイント

- ありえないことをすると型が never になる

```ts
const d = {
  a: () => 22
}

const f = () => 22

type Foo<T> = T[keyof T]
type Bar = Foo<typeof d>
type Baz = Foo<typeof f>
```

この時

```ts
type Bar = () => number
type Baz = never
```

になる等。

これを使って、Record ではない時は value を返し、 Record の時は再帰的に `DeepReadonly` を呼ぶ。

### [Tuple to Union](https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?ssl=24&ssc=1&pln=25&pc=1#code/PQKgUABBCMAMEFoIBUCuAHANgUwgFwHsIBVAOwEsDTJEE76aAjATwgEFS8ALK1gMVQQAFAAEAhpwBmqAJQQAxIFo5QFi+C8qUnYATgrwYcC1BSpga88xEBXMYHlVU1ED9DIHWGQNcMgOwZAJAqBpBkCRDIDOGQNMMgFUMgM8MgNHqgEkMgPiugAhGgJoMgNEMAAZoWNjIBGSUpAA8yAB8ieGA+dqAoxGA6gyAfgyxgEAMdhCA0fKAEgyADgx1ie14AM40eMzouGxaOgC8EADaAOTQEwA0EBMATLPzAMwTALp1vf0o2J14EKMpOOmZVNmDWnkQwMAQ2AAe-QDGeNgAJvhEjLhTExAAH3mS0BqwmNHaiTq1wA4uQ8AAJVCMQDmDIAuj0AsVEJQBY-1w8Hh0J0AFy3LrPLgAOgAVp0KQQtABzYBwYBUsRgEDAUygCAAfX5AsFAoggGUGEWAawZAM0MgB+GQCTDOFABhRgFNFPlCtW8iCc0zbXDHNIZYw5fKHFD3B5vUjvTrsIZiZjZdSaHQASWQAFEALIAZWuAH4IK7PV6IESIKRsAA3bQAbm5IFV6sFEEAYwyAToZABMMgEaGaWphOJ-marnkAC26HpBx1EAA3hA3QBHVBiTBzN1PbCvCAAXwgki0BGL8xEOoQ5KbOFIDL2wFQeHImE64LAleeYk6exNYxorZeeGy9cbmFy+n1ZxyY2gCxWcwmABYAKwANmWeC0qGw6zycwvK1Bt8f-yBF83zyT8tzbV49wbJsj1SU5DWyc9Lw-L9LxAmYwE2MAeXzJNAEJrVxU2TQBhhkcPN80LLDwCga5AGPIwAVb3CQBHRUASHMcTxAliVJTpyWpWl6SZFkJE6AB3bRWXZaiIHo8JAGjI+JcXxQkSWAMlKRpOlGWZWBgE6AhMBnLJukkwBdBlcQA1uVcQAmqMAGQyFI45TVN4jSmTZDkuSAA)

ドキュメントの[ここ](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)に書いてある

infer を使うことで、 Array から Union 型を得ることができる。

### [Chainable](https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCMBMEFoIGEAWBDAlgO3QIwBsBTCAeQAcAXTAe2wGdJEEXWm8BPCAQW0tTpcAYgFcIACgAC6PgDMRASggBiQLRygLF8V6cuQKYAxump0wTZeYiArmMDyqqagApdADd0AZX0AnTFQiBzBkD2DICADICDDIDlDIAlDIDPDID3yoC-AYBWDIBVDIDrDIDtDIDnDJGAMgyAEQyA8gyA-vKA8QyAMQyAfgyAmgyAQAyA6gyA0gw1gQAqHORE7l4+gNYMgOBKgFEMgP9mgBIMgPoMgBYMgLIMgYDG1jV5gNHqgEkMgBtygIoMgNEMgMoMY1m+E5V1gPj-dhCbgHYMgE1RgDIZAYGJgGsMgB0MoYD1DIATDL6AQQwvgJcMgJ0MX0AqvJfQAiDCCzr5AhAAAY0Ki0bDiADWRA4ABoIC4CCIiApoRAxjCAOZESjiPEQM4QeCAEwYzoAi1MADqaLQALxoBs+Qq6yWgCztQCV-jVAGYMeUABgyAVQYQVVYfC6PjboA4OSGgEiGEojQC1DIAfhjGgBIFRYFQDGDALAH-OgAp1Kn6OiyTBEylLQCHRoBWfT2lSqgABzQBCvoAQt3igAVfQA55v5iaTZYA15UA6fqc7ZdGplGqAcIZAGIMVROgGj5IaABwYTtCs5RGFAACZEfQEdAeEjmhiUCDly1EgBcKAwOHwxBO5foldL9BEBErAF4qxarUwoAA6OHGREAclkNBok4xcAAzAphxAx9Kp7gALZEecQSeUVpEBD6DAEYjYEn0ScrqCj8cI8STvAlvcAb0x6GxRHrk4AEkQ540BAADqNAeAQeaThAAC+t53iOJJkiuTDAMAEBEAAHm0+iVvwJCHm0EA0LIECdt2eHAXgP5MDglBEB4sjoPoJAAEpEF2PYQG+q4zjQ9bYCIW7UR4q7bj+EDtl4l6ri+Hj1jxd53liOL1lJOBEquMFMNpUBZtCJznNYVyLIAx5F5CMgCBDF0EAAFb0MAOaUoAtwyPIAwwwvIsgAfZnkgCj+oAgZH+IAQgx9GUgDaDIAyQxVPMgA3DIAmwyANcMZyuR5wqrN5IJCmKEqZiiHD4gG0LqZe+JnIA-gyLIA68qrGsgTQipRAFYA33KAPCGZxLNVazrGMgB3ctygqfIA05YguFUWADAqgAaDDCeX4lk1IQIAe2qAIR2oolFsYzBaFkVJkwAB8EAAOKYJQf4iHgviAF0egCxUZygBY-6glCUOQ9C1mhOaniO9ljh4RLAHAwC2egYAgMApigBAAD6UPQzD0OnJsXSAM0M6qAJMMiyABhRgCmipDsO4xDEAg6YhEkGgWC4IQRAADysRA-Y0HgtmFpQ+39opxEbpTADSGGYfR2B5vQkmUNJRIYgAartyKovW3NYXzAsQHlJEQDTAD8EDYEQTgMRAMsYg19Ziwo9ak02FOU6QW7HdTGKc-tABkKuFuBeZc+Lu27UwSHkvWrFgNpYDg3juMQIAYwx-G8gCNDOqfw48HcOE5gW7kOBeFHtxPB6CiGIAKLYUzsEQLIHg0Fu+6SMTJ5nheV7ACI1AENepgFkWJZlnQ7YQOgJuNuTLZgG2HYcRR0C013TDrhOT58XuS7wZPj7Pq+GIfgb+4AUBoHgZB0FwRPD50E+4l7geR5V1+NccTeE-eyhg9kcPPbwP2QP3huR-oDuJ8yDQ+EeBrn9dzwTQhACu9AEBYRwpQCBHgS6iTflPScx8MSTmLJ3Y+89b6mHvuRHsi4x6vzXAfTcgDv7YF-qgHWGDULoTARA-OuEYFwP3u-JBpCFywGXDfUk5Iibp0MPQDiY8ADaTA85QMptwLOVNibK1wZQaAucGH0TzNAD2aIxHKMkdIymsjSLyNgEoqBRA8ywHUZoiRUjMAol0UeORj9KCLiMUzExi5zEAF0+FEXES41RY82Z8QEkJES7ASwKVXGvYqmkoC6QATuNSwsNL+y8SQHxuETHP24kwcSCSRbJLAMTCAaSVH4NZtkwBQThIMXyUHeOcNACE1mcP4oc3LJDjnUgmoNQB7QgKZQAKt6LEAI6KgBIczug9J6L03r0A+l9cCv1-oyHoAAdwYgDQh+1+mLEANGR6x7qPWeq9Ry0zUCfXoN9eZsBgD0BoNiCcuYID7UALoMZxABrcpcK4eyJmHPeic2ZP01nA1BkAA)

- `K extends keyof R ? never` で既に存在してる key の追加を許可しない。
- 再帰的に Chainable を呼ぶことで、 R に型が追加されていくイメージ

### [Last of Array](https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCMCsEFoIBkCGBnALhA9gMwgEEAnY1AT0kQRtqoCNyiA7TACx2aYDEBXCABQABVKzy8AlBADEgWjlAWL4zUpCmCrSNEQFcxgeVU1UAHwRAygyA7BkBNUYBkMwOYMgewYAKuQAOAUwDKAY2IBLJ9gAsAHQADIAyDIAVxoAWmoCqDIAxDIB+DICaDPoQgLKJgOhKEAAG9lkQgEkMgOvKgIoMgGvKgFEMgIAMgLoMpoAA5oAx+qaAgZGABL6mgNHq+YAr8YmAcjaAFK6AIW6AVgzZaFgAPPYGefmA+dqAoxGA6gyAZgyA8gyABgzRgCIMgEAMKYDR8oASDIAODClZl5joVJjOLhDKxNAQALwQANoA5KhfADQQL70f6AjxfAC6t3uj1IACY3p8AMwA2EA6CQqGuCCYVDeAA2L3eE0wkye0CMwGAEBcAA9XB5MC4ACbYnAQegPL5gzEPHH4+FEjAkp6wilU2n0xkszBsjkwKiXLIpIwAcW8mAAErx6NZAF0egFioxKAaIZAFj-bEwmCc6AAXJTrh42IEAFboQI4YgAc2AcGATtQYBAwDUoAgAH1wxHIxGTMZANYMgGaGQA-DIBJhnygAwowCmimGoznQxBA2o7ljidNqTTGcwmehHlwPuCjO97GWK1XPoF295mHgXMQIAAlAGd7u95DgiAAfhQEGtEGYLgAbj3gyBs7nIxBAGMMgE6GQATDIBGhkTW9Xa-D+aD3gAtk53dgiw8AN4QACiAEdeKg8QCn3SXAyIABfCA8GIHAL0BIQ7wQB0PzxFxmA9Fx0GAXhMHxdAvkLaEPAwRCEQ+Khv0lSZX3fPFJhLD5YXrFEDAMP4CJ-BliLfD9yKFSYPmRCBURgaiYFo+ioEI38SRI1iKIEKRXiMaBYS4x9UBnLAfHggC+IUpTMBUj0AIEsAMRDE910AQmtTC3DdAGGGQB1hmPE8zzAUAqCMQBjyMAFW98kAR0VAEhzY0zQtK1bWAe1HRdN1PW9WBgFEdAAHce19f1DAgNz8kAaMjTXNS0bTtdAHWdV13S9H10BwPEUO8TgbiS2pADW5CxLD8rLAuC-Kwq9P0AyDIA)

- 自分で書いた答えのポイント
  - `[...infer _, infer L]` とすることで、配列の最後を得ることができる
  - infer で array を展開し、最後の値を返す。
- 別解
  - `[any, ...T]` とすることで、any を先頭に足した 配列を作成する。
  - `T['length']` で T の最後の要素を取得することができる。

### [Pop](https://github.com/type-challenges/type-challenges/blob/main/questions/00016-medium-pop/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCMBsEFoIAUD2AHSiE91gRgJ4QCCAdgC4AWqZxAYgK4QAUAAgIaUBmjAlBADEgWjlAWL5COAJ0kdCYLIMURAVzGB5VXlQAfBEDKDIDsGQE1RgGQzA5gyB7BgAqhdAFMAygGNJAS3QUIAFgB0ABkAyDIAVxoAWmoCqDIAxDIB+DICaDBoQgLKJgOhKEAAGFskQgEkMgOvKgIoMgGvKgFEMgIAMgADmgDH6eoCBkYAEvhmAJmmAIgyA+gyJGYAr8VGAcjaAFK6AIW6AVgwpaOgAPBaa6RmA+dqAoxGA6gyAZgyA8gyABgwhDYBADLGA0fKAEgyADgyxyccUAM5YFNY2EFKS0BAAvBAA2gDkHK8ANBCv+F8-Dn+rwAJq8ALoXK43aQAJkeLwAzN8Yd9oBDIbYIJIbPcnsMRrdoNpgMAIDYAB62BwUGzAiAUVAQfDXN4fb6-IGAiFQS6Y7FwvEYAmw4mkilUml0hlMllIiAw7kpY6xEAgQBSDBEcqqAFwQQAwKoANy0A1gwpOxUZzcCjJIpDRinKjWlIAVTI9otVoggCCGWYmQCyDNFANIMgHx-2LaADizgoAAlGPgTIAuj0AsVFRQDRDIAsf6oFAo6FO2pJZwcVC8ACtTl5UJIAObAODAYscMAgYDyUAQAD6Hc7Xc7uh0RsAzQyAH4ZAJMMGUAGFGAU0V292Z22IE35LzrviLGTyTSyMDTjc6M8wdonhY3gAbGxkSvUcFrjdbiA+CAAfheYIgutXFJv2+eXh-zjI3BsSRSG+LhCBfJ8SFfCAyBsAA3QCAG4WxAadZy7CBADGGQBOhkACYZAEaGQcsNQtCO3nZtnAAW3QCt3CXCAAG8IAAUQAR0YDhj2+JjKRsakIAAXwgbhJFQCifjYJcEELDjT3PGxTmARgKGcY9TleRcoQcDhTnk+FniwbiJRGVj2OPEZ8WeOUURgfdvks5F900T4DJ46ljLYjjzKFVkgT+dlAXZUFbJed5fM5cFNCclyjJMzyLOCvdIuc9FWxI9DAEJrPQsIwwBhhkAdYZiJIsiwFALBtEAY8jABVvDJAEdFQBIc1TDMsxzPNgALItS3LKsa1gYAuFOAB3QC6wbLQICqjJAGjI9NM2zXN81OQsSzLCtq1rU5UGPJTnFoc4xsAXQY9EANblDCMJq5ta9rlq66t60bZsgA)

- array を展開して infer で型を得ることができる。
  - `T extends [...infer R, any]`

### [Promise.all](https://github.com/type-challenges/type-challenges/blob/main/questions/00020-medium-promise-all/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBBMAMEFoIAUBOB7AtgSwM4FMA6AQwBtTJEFqbKAjATwgEEA7AFwAt1WmAxAK4QAFAAFiHAGYCAlBADEgWjlAWL4LiqVMSbyADhhwEwleSYiArmMDyqkahosefBECXDIBKGQPUMgKwZAVQyA1hkAdDIHKGV0AJhkA7BkBZRMB0JUAkhkB15UBFBkA15UBohkAi1MAHUwgAA1sDfGZyTIhAawZAaPUowA25OMAzBkB5BkADBkBVBkARBkAgBkBuI0AohkASBUB7Biyc+wAeABUAPkLAcwZAIQYkwFH9QEDIwBkGKY7APwZATQYWwGUGLYnAQAZM4cKewGPIwC8bBsAYhkB9BkAFX0Ac83CIic3rLMzM9lxKAGMeXHYED0dgIAEYIABeFD6eyEVD4XDoUgAN3wwgAzDIANy-f6A4G5aCQiAAFmgOKgf1YAKBMII6OJrHwAHdoSD8IMAahsKwAOajYTCeGIlH4AA0EHhACt8D92HIIaMIABvShQAjsYbYTD4dACdhChFI1ES0GwWASgDkknQ6Et2MoAF8HZRgMAIPgAB46WXsfAAEwg7HQEDoDmydI5AG1WAJMGHUBKyRKuTzeQBdca46n44kDAj5UjCKME+ygiWlgjQCuR9HpiDEXAQKkAmSUD6ZN5KgDi2HYAAkBHQJoAuj0AsVHrJKALH-OOx2DpcAAuN1fH6cQhS3CEdCoXnAODAKXEMAgYBGUAQAD615vt5vEB2RUAzQyAH4ZAJMMUUAGFGAU0Ur3f-5eECnkY-qyqQ6gONIrBytgPBsrkhYjB6np+qw-pNhIDBRpmwjImQAgIouEBRoQpHDOmMhEfmHKqlAUYANIQDyEAANb4Aw6CSBA5FEcwzLEH2AYjAxmZgI6ozniAf4AbeECAGMMgCdDEEgCNDC+CnSTJ15AWe2o6DugLsAwPoqhAACiACOAhkBKpner6ECOhAkj6BAlqiIZPoIGuZCkPgfIIsA+rYKQuCWkYLb4pGhbDAi7DglC1GFsW5YwBKdYNk2EVthFtLstFsVEglUXkMlErVvBsLCsaaKYvWjbNni2V4rlCHkDFAIMkVeUlVGKXldRcJGqKGIyBRYA5ZWeRtbFJJ5sVpCDMwGhaIMsbxvgqAQAAPhVBCrXGCajEdpWpRAdZtmAHkOD8jYIsSUaULZPpyoMFlWQtV2cS19j5QCKXUYMvVlWlmZHWKj12S9b1kIMn1cZNv3sP1kaA31EprQmoOjODUBPb6r2WTDcPfQW00dRKAMxgdG3o9TiYQBjG1YzjZmQ+wBPvbDRm6vD83tewJIUyjjOoNhR3Y2A6aSRpmkQIAhNYhApcmAMMMgDrDDLMnaWAoCUEqJyACreUSAI6KgCQ5pOM5zguy7AKu66btuu77rAwASLgzIbYex5QHrhuANGR06zvOS4rrga4bluO57geIpBf8usQIAugwhIAa3IhIATVGADIZFtB9btvhw7e5HieZ5AA)

**関数における Generics の使い方。**
  - 暗黙の型変換。型の制限。
    - https://zenn.dev/miz_dev/articles/typescript-generics#%E9%96%A2%E6%95%B0-generics-%E3%81%AE-extends-%E3%81%AB%E3%82%88%E3%82%8B%E5%9E%8B%E5%88%B6%E7%B4%84
    - https://www.typescriptlang.org/docs/handbook/2/generics.html

**Mapped Types についての理解。**

- Mapped types on tuples and arrays
  - https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#mapped-types-on-tuples-and-arrays
  - https://scrapbox.io/mrsekut-p/Mapped_Tuple_Type
    - ここも参考になりそう
- Mapped Type
  - https://typescriptbook.jp/reference/type-reuse/mapped-types
  - こちらはパッと思い浮かぶ方。

`keyof T` の `T` が tuple, array の時だけ挙動が違う。配列を返す(?)

```ts
type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };
type Coordinate = [number, number];
type PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]
```

### [Type Lookup](https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBBsBMEFoIBUCeAHAphAMgezwGsBXdSRBSq8gI1QgEEA7AFwAs8n6AxYiACgACAQ1YAzYgEoIAYkC0coCxfWcSYBLTrIC2wsuRn6IgK5jA8qphyAVTUbA0eqBpBkCRDIE8nQFnagOwZrgJIZAejqByAw+B-eUBjBkAzBkA15UB0-UB1BkB9BkARBkBlBkALBkAZBkAhBkAohkA-BkBNBkAgBjMoeNdAJqjAGQzAcwZAewZAQAYAAwBhYRYIAB8IABE8AHNaiETYwDEGCEt1JghrQGsGQEdFQCwE7MBohghalgxMXv6BwFWGQGKGQB+GQGuGQEmGAJDqwD-tQB39Bc8IyJzcwBMGTPTqwFO5QGg5V0Bo+VdACIYBibVJb4IjmdAAHk6XVaEEaLAANBAAOQAE26SIAfL1XIAWDUAECqVJZQ3oeOogwhgyHdGFwxFIgDGTUx2PxhIaTRJEQWSQmgCsGLJ5ApLWrLADO5FUrEwACcxMJ6dg4RAAN7kKArLAALmRjJYSLVEBo0swmBRou1SIYdFFoslqlESJhSIAyhxpexhKppY62kj6sRpQAbH3IgBCmCYXWEwfIAF8hZKWDK5QqOtTVVB1asLWiuvrM4bjabzciABJ4FQokNI0PS1QsFiiVDV0PEQOB3MtvAADxl+cz9Lwgbw0otRrwAHcmNWJ2x65hqzRA-LCP34+QNdgALKoKEQAC8uAIFIhSraULpnYxEGAwAgmG7WHpSZREBYeEN2FqxPIItqQuvABxetS2IGhykALo9AFiohZACx-tgG3Qc1bxYUV6TYAA6AArUUMJHLpgDgYAsOEMAQGAMxQAgAB9Wi6PouiIHieIJkAZoZdmOQAMKMAU0UaIY-jqIgcjKLvTcj1BCFzERZBr0Pcx727JMmDNFVN21ZBYwgAB+YYIG1JhMAANxlABuMAxPJSkpJQBSlJU0UWDrSNZJVcgAG0AGkIElFAAF1tXkh87NFFU32zGzNJ0+T9KMmUwFjNzkF8yiQD4gT6IgQAxhkAToZAAmGQBGhl2bK0vS2ihIo1RNHQEdmjE5UIAAUQAR2IaNEQax9MGfCBNLEaU8E0ZFBE3BB0OjQMIy6TBRWAYgWFUQNRX1MBE2TeVFSaVysy1HUmVoIszQtK1UBtO0HSdV0arYT1vSdf0gxbSbo31ddVtlda02hDMwp21F0X2k1DrLCtlJbOsGybFs2w7dEnVDHs+3IQdh1HZFxynGc5yTRdl3pVd4rMMTmEq6MD1hTbz26QnVggRlRWmsm3PIDqnxYcFmtawNwUsiFie0QNL3RDFEShDFheZzrn3Zlro2549KT5trdr1YXyZYMX4TAZKwCo0qMsAQmtXGyzLAGGGQB1hhK0ryp18AoGvQBjyMAFW8PCmQBIczghCWCQzUULQzCcLw6UCKI0RRQnGViNIu2ICdjxAGjI+Z4MQ5DgFQ9DsNw-DCNgYBRSHObRnFaPAF0GVxADW5EpSiTr2U7T-3M6DyOyIooA)

- in で loop のような動きをすること
  - string に対して使うと、一度だけ loop してくれる。

```ts
type Foo<U, T extends string> = {
  [K in T]: U
}

type Bar = Foo<'dog' | 'cat', 'bird'>
// type Bar = {
//     bird: "dog" | "cat";
// }
```

- MappedTypes
- Union に never が使われると、無視される。

```ts
type Foo = string | never | number
// type Foo = string | number
```

### [Trim Left](https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCMAMBsEC0EAqAnAlgWwgGQFMAzAF0mSUqvICMBPCAQQDsSALAe2YYDEBXCAAoAAgENWRPgEoIAYkC0coCxfOSQLYADgBtRqpJsyr0ozWHKzzEQFcxgeVVTUQOGmgdW1A6EqAkhkDryoEUGQGvKgKIZAgAyAEoqAtBmAdgyAXl6Avm6ugFJKgCZpgOoMgPoMgA2mCYAiDE5ugCvxgJoMEAAGGDiEpAA8qAB8BRCugPnagKMRCYB+DLmAQAx2EIDR8oASDIAODJ0FQyQAzuQkdOoEECRY2AQAJhAAvGhzpSRlAORQABIEmpocEADqHOiaSxBblRDAwBAEAB5TAMaqSyTHNNNb+4fHM4XK5bchDAqdW4AcQMuz4NEA5gyALo9ALFRuUA0QyALH+2CQSOoRgAue6jV5sAB0ACsRmTzgBzYBweDACmiMAgYCmUAQAD6vL5-L5EEAygxCwDWDIBmhkAPwyASYZXIAMKMApoo8gUq7kQdlgCZTCAAZXUole01WOx2AB9rgAdZhmy0kUFa6bFbAbMo6x5PVTMBYjCAjWaYZi026rN3PT3ewoAEgA3nqDQQAL4xgNEAjoCAAJQTNQA-GsSsRNhnbgTdZyQMrVfyIIAxhkAnQyACYZAI0MkrrlarvPVHJw6nOJBmk2m0YgAFEAI58YwAGlHLwI7wgCYgRHQHFwW2EDqQpOMmgIgYII2AfBImE0I1BmsHEFeohGh5WEAA2uQR3P3mVx5PNBV1oXtn66A3DOWyATclRTq+76bF+xi-gW5Q7GBEHXMhEFQW8METnBToujsUBQMhIFoZBUBvphn7YT+uH-vhBGAQRUDAahsyMdclToWR0GUd+8HOrRBFWha-ZEBw3yiOmzFbKJ4mSRxpGzhRsHUX+iFSeBCnkfOWG8TRiEQEJdooVsGlgAAuuW7YdhAgCE1qEdY1oAwwyAOsMVlVl2YCgOQtyAMeRgAq3q4gCOioAkOYYtiuL4kSwAkuSVI0ug9KMsA4gjAA7mmzKslAvkBYA0ZFYjieKEsSIykpS1J0gyCDACMHCaCemBcGM2UQIAugyhIAa3KhIATVGADIZ4VFVFMXlfF9IsmyHJAA)

[Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#handbook-content) を使うことで、 template literal と infer を組み合わせて使う。
これを使って再帰的に `TrimLeft` を呼ぶことで、全ての Space を削除した型を得ることができる。

### [Trim](https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/README.md)

- [Answer](https://www.typescriptlang.org/play?ssl=21&ssc=1&pln=22&pc=1#code/PQKgUABBCMAMAcEC0EAqAnAlgW0spBheARgJ4QCCAdgC4AWA9leQGICuEAFAAICGtAMzYBKCAGJsAUwAmmNtnE1J2AA4AbXkqRrMS9LzVg8YkxACKbSQGcamJkagBJVWuWTaEAAYYcAHlQAfJ4QAO50mADGdBA0vADW1hD8EJIAHrwRNBA2WFQA5jGkKpJJVNIQ6JI0bOhUVkkQVJIh2TS5BSG60fQlYbrWKhklAugMCsQM9Cll9ZXYDABuMgB0DhAsDOgp6S6Sa54HNFZ4NEUlbThS5QC8aFjYvgDkUAASkmpqDBAA6ptq5RBHgEIMBgNtipkZDEvsQSo83h8vr90P9HngDp41sCAGqYZoQJgQADiuhebGIAC4IHQaDQVFYKaCjlFlgArKzLTZ5YBweBgEDAIygCAAfTF4ol4ogAE0GDUIABhBjSEpvSqiyWakUQAVgU7FCAAZUGEUSt2ezwAPoCADpUK22miPADcerOdz8hu2ShmrXawNuXrSPuk9U8ABIAN7GoZWAC+UcwVAEki2qDjwWtEcjSZTaYT0ZN1gzEAA-B6HoEIFTDUKQBqtRK0NYsgreFZEo3JTrBTgVJssvqSpGIABRACObAMABox6kIVk4xARmNAdwh0gogZXPlrMA2LY1FY0W6DRF22aIABtPCj+eSTK+CdTtT+e5PHJA2ePT8BALT2970fZ8DDfPxnl-b9f3-QCFyfSdQJ8B5nigKBIMBaCAKgO84JA18kI-NpUK-DC2iBGDsKAmh4JfMDkNQtCiIYkifzIv8sLnXCEPw98UIgO0bSyAQGBhXgtkEljhNE9ByI4nCH2ovC6KeFjZNghSaMQ3j+KoQTAX-QE1IAXTrBsu21dh0B6LZDSUekzK7HswFAPBgUNOgxJKUg5S2KwGDUA87DqKkaTpBkmSsFl2U5dBuV5YB+CsEJU1ciBcXxPyAtsJgGWpWl6UZYBmToNkOS5HkEGATLApy1KAFlNhKBUPI+dw8msEL8vCorIpK6KuX5QUgA)

Trim Left の延長

### [Capitalize](https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/README.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCM0AwQLQQMIEMAOBLALmgNlgF4CmkSilV5ARgJ4QCCAdjgBYD2zDAYgK4QAFAAE0rAGZ8AlBADEAWxIATLH3lycJeRnxpNiQpoBOBMOVkWIART4kAzjixczUAJLb8WkqwgADdNh4hKQAPAAqAHy+EADubFgAxmwQCVwAbiRGOHYQ7CQQ4lhGDhCeOMYQHOIQaBAORljMAOa5HBB8GBiZCWh2+WJKpSRoGbls+Ub2ODV2iFh2AHQuEDwcRhAkAB5oHmTkvgfZ5Dh0XSmYuATEyhAAvKgXQdchAOTj+PhtMWv4Si8REGAwA2my6CU0gxwbRo+ReAAkSB8vj8-vsDssAQA1LAkGKVZgQADiuDhfBoAC4IGxyhg7OSgdkkgsAFaLNZNYCwOBgEDAMygCAAfWFItFIogAE0OHx1igOEp8gjJkKxarBRBeWYTmcALJ0AKXYIkEIAZRBmmYShy9UaTQB9zNWwtVr8ABIAN6NcSZCBhAC+Hq9PoASn7ogB+N3ugCqnW6vWNkQD7tD0UpJoA3PyQCq1aLfVMHn0cnmxRq+VhtGtptr8u6IABRACOfAIABpG6CSOCIH6CkYOOoXsJa4gkgRPM17MA+I58HYXlrTvkesW7hAANrkBtd8EhZut-AhPUGp6hF7iDgcGhoIz-DsvVbX2--CJt7e7nD7lsEY-6x5XOePAAPLAQAQowwb3hAj6gRBUERG+H5gl+B6-ieAFGq8l7Qi+b4wU+EA3neiHvlAO4od+h5-qegHGi80EMaRyHdqhP5HhhgR0a8aCMYwr5kZ2lFoRx-5cVhLw0IxYECSxe4iTRmHPC8CSMSgsnkZ+VHoWJhrKX8+EvAAIhpQmsdpom0RJJCMQ2pkUeZCmcXp57iIxPD2VpTm6We9FNIxhKecJ7GKeJylsIxcJBY5IXOb5rxYIxrjRfJsU+dxLzMoxABSKVsdRcUZQA1oxADSeUWaFLn0fgjEADIVd5VnKfIjE6o1aXNeezCMQAch1BXpRJHCMcBA06V19EYIxAAK42WUp55NoxVjzVV8UvCRD4IUhmnBYNk2vAuhkmmthUSTgjFhGdQ3KXwjHRjdh0vGkjGYk9i30TEjEAOofWF56bIxAAa-3Va8dCMRKYMbUQjEAFqyQAutmualuq-BZOM6wmpotJo6W5ZgKA5AAiabC3vkdDSusdgcPgs5OMwdJUjSdIMnYTKsgs7KcvAwBiHYMSZKTEDYridT04zXAs9SOC0vSwCMmwLJskYHJcsAdMM44Muizqaz5CgFMfN4TT2JScsKxzXNq00PJ8kAA)

- string は `${infer A}${infer B}` で、 一文字目、それ以降に分割できる。

### [Replace](https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/README.md)

- [Answer](https://www.typescriptlang.org/play?ssl=22&ssc=1&pln=23&pc=1#code/PQKgUABBCM0GwQLQQEoFMAOAbAhgYzUiURNKICMBPCAQQDsAXACwHs7qAxAVwgAoABHIwBmXAJQQAxAFs0AEwCWXaVIZpp2HGsRYFagE44sYIpLMQAilzQBnBgrYmoASQ1Z1aRhAAG6TQQAeAGUAGggOfRZpMIAVFgA+bwgAdyYFPCYIfUxcAghmNAg7fQU6AHMfCKik5L1M7ziktjzS-KZCsoUAN08ihhLynyDvJ3CWfQg0AA8cN0Iib0WGGyIGSgxC7P95CABeVBz8NACAcjWNmwgcbIhROgBCE7CTu6eIE5xk2yi0E-iIYDASZTDZ4NRyfIsCDkQpnda2K43T7fWSPBaLUb-ABqCjQyQgbAgAHE9AAJLjkABcECYDAYGBslMBywyADoAFY2VnjMrAWBwMAgYAmUAQAD6EslUslEAAmiwuBMAMIsOSFUloG7S7USiBCkznQp+XLHILAtR0OSXYqlMphKoqaYWq19AZ2iBxc2eF028r-fYOr2Wy4nE5EAD8ECCRGpZqd3su3gAJABvUrCTUQAAyaGEDAAvqmHYW03QMxMUAoyrT8yMoJHkymc3mS3ES5XqwW6xBYwBuExgUU67Ue2wMCBKnA2BHD6V64UKDTjceGiApiAAUQAjlwjGENyC0GCIPnbpEVCd+IbEBkjO5yrZgFx7FgbGGwKu8FOEfsANpEA9QQYAJt13LAAmNI5TmEFgWHIa43hOeD9EQmCWD+Z40LQv54hCADDzBECdyMCDDkCF5YOQ5DEOozDYIw94sMohD4lw-CgKIsDSO2aDmP0Wj3lQ+jcMYvjqNYvCoEAo9gNAkjIPItCqIQ54BNDESKLgli2KkgjZOI8CFOOTTlJQ1TDCE9CNKU65xJ0zc9M4+SyOMxC3I0nC8IAXRFEBxVnGVuH0AoJiCNQGX8gKxXnQdwCgf4giYa5CkoBUJhsFgsGfBw6EZGk6QZJlgBZJgOS5Hk+XgYAhBsL59CIbFcXxDKsvsNg8tpelGWZGw2U5bl9F5flgBa7L2oaiAAFlxkKJUkqwe8ylsalOsKnq+vKwbBWFIA)

- infer を使って分割する。

### [Repalce All](https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/README.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCM0JwQLQQEoFMAOAbAhgYzQEEstIlELKyAjATwkIDsAXACwHtH6AxAVwgAUAARwsAZrwCUEAMQBbNABMAlrzmzmaOdhybEWZZoBOOUmRkWIARV5oAzs2WcwZAJLasWtCwgADdDoExFgAPADKADQQ3EbsclEAKuwAfL4QAO6synisEEaYuAQQbGgQpljFrKV2vNQORsqMAOZ+MXFp6Ya5vklpjZWlTcoAbt4Q9Y0tvmG+LlDc7EYQaAAeOB5oc36+vsx2ZMy0GKX5gUoQALyoBfhEJCEA5MwQ9BjL4w9RDxCfPw-JEGAwGWK2OeE0imK7Ag1FKTyO9geZB2szIAIAaso0OkIJwIABxQwACVqAC4IKxmMwMHZSUC9jkAHQAKzsjMWTWAsDgYBAwBcoAgAH0RaKxaKIABNdi8JYAYXYilKRLQ+WF4o1QogfJch2O1zOwXCIM0jEUdnGzAazSibXUq1N5st1qaiWhDu8TomzQBFzIdpNnotDyRUCgAH4IGEyFByWFA2aLb4ACQAb0aYlVEAAMgBfNN2-PpxiZpYoXOzMMQSMp1N5tNJIsBQp3UIoW2xeIQJLJCsxiBxgUgdWasXd+zPOU4Oz2EejkXa-nKbSLZ560qpiAAUQAjrxTFEt6C0OCILmIGJOz8hOvEDlyt4mvZgLxHFg7Ej19FLgaW0aHmI7DsNQOBGIBwGgb8DzAVB1D-F8gEgWBEFGP8ADcYBfng06zlcADaZBHmCzAhLu+5tjcQT3ABQFIbBkEIUB8E-OB4H-MkESEce4KkXupghM2tz-uBdFfCBTRQWxHEsbRkHJBxXHEbx5ECZRraPCJoGiT82k0ewzF6axTHyZxUBESeJFkfxglUaETwvBAbzVFBPxfAZ64fiZikWcp1lqcJslGLpknGYxKF0V5ZncZZfEUYa1FIWxYkMTJ+nSYZxkKVFSlWXFf7UZpyEoVBMFiQZiGgRVqGRdu0W+XlQkFcBQHIdQ7ApQ8bWweVzWtXJWW1TlsWqfFdlQeN6XsZxAC6Q5zvO0SyiUSxhJoNLzaOi5gKAaJRqwoGlLQMpLHY7BYK+TiMLSFJUjSdLAAyrAsmyHJcvAwCiHY6SqrtmLYuMZ0XZw12UtStL0nYTKsuyRictywCnedjjA7tACyiylHK+0kI+9jkqDd0Q1DL2w7y-JAA)

- 同じく、 infer を使って string を分割する。

### [Append Argument](https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCMCc0QLQQIIAc0FMB2ATVATgOYCuAtjgC6RKJ300BGAnhALICGAxgJaYBWEAMo8A1gHsCHCAAoAAmW59+AZzGSOASggBiQLRygLF9dHYuSoqwNHdYiArmMDyqpaiA4OUASDIEiGQDEMgfQZARamAHU0Bo9QgAAwAxbBCIQAsGQG+5QHhDQDsGYJCUKMBrBkA-7UB1BkAzBkBABkAab0AAOUBUfX900IiowCSGQDXlQCiGIsAYuXLK1NrG-PDIiES20LSIGsBf+MACpWy-INCAcVrAfFdABCNswD8GQE0GQCAGJwhAaPlXQAcGfO2Qk8pmLBUuAh40aigzrAgIiABeWQ4ALghsckZMAgANBBGF8VJRrtgiNoXgA+b6-f7bB6YCAAJUwKhIABtKK9UBgcLgUKYKNhKAAeCJAxjicRYzAcbAwmjAYAQTAADywXEomHwf3eXx+ZD+gOBoPBPEhQI5XxpdIZ2GhcOFopoJxC2zhgGUGRIOQD2DPkANoKJQCNQSKQAXRkAAtKJQ0CoPqyiDxKLaSIwAHRccRkYCKXjm9RSbTpQARDIBohiNgGFFRKADCjANFyNvtjudrNwmAAbt7KOJA9wLRpgBxcNnGVw+YhkZdrrdEJz-rwVBjEABHEgYyg8cTYRAAFkHsAArFxNIBpBncgG-PQCwloBVBk8K0mWxocJm7oAEl7AOYMgC6PQCxUWso4Asf7TTpdwEol1t3tU3skRGAcGgwH4HDAIGAllAEAA+gBgFAYBEDatq6SAM0MgA-DIAkww1AmgCmiv+wEoX+EBfpYyL4lgeDEqQpIUlSqBwm8zycryeAqLI3o0SYRDOhAUoAGb-IQ9HKox2AsQQEAACoQAA-NRtHEAxRo0d6eEqECKBWhx-FCjmiJgL+qEoRAgBjDIAnQyABMMgCNDFBWnIWpIEYTwZBoJIuJYQA3hAACinYcFiQL2VymA8hAAC+EBMQQ-oQAA5HIyKIFwtrOfSkIYsAJA9liKiBZh5wogAwhwrYIG86A4USJJUOSMifPCIr-NSEoQlCrwqgiYryvSjLMlh6KYjiWWCiVorlRAYKVTKcq0g1SrVZ1ylYelrYAEx4jlhJ4WYZKFRx2biDwuBAiQeCYExUp8k1KVohi2KUNNbwyLKECbVmO3YHyy2rbgyWPFwGUYniRo0G53IUo5JDOeSE2YNAQItcd0AwjCAKfe5PLkr9-2A5NINHTik0Q1DUCshAIUqI2MOUI2BD+QQNCzbh+WLZtojYOIADu2AbVtN17VDVo-iAxkmWhgCE1okWkaYAwwyAOsMnMmeh36gGuECAMeRgAq3jUgCOioAkObHmeDoXqy17hXeKgPsQz7wKW2AqLT-xvh+UBwnLNSANGRp7nhmV43jretPi+wAqHScW9sbUuALoMiSAGtyiSAE1RgAyGWr6aXlrt73o+5uft+QA)

- `Fn extends (...args: infer Args) => infer T` のように、infer, ConditionalType を使うことで、args の type を推論できる。

### [Permutation](https://github.com/type-challenges/type-challenges/blob/main/questions/00296-medium-permutation/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBBMCcBsEC0EAKBTATgWwK4BcBDfASwHsA7SZJWu6gIwE8IA5Qs-MiASQGtcFbgAoAAgAdCFACZSyJTAEoIAYkC0coCxfVYPJVqKgxEBXMYHlVMNQCqFXREDR6oCSGCFZu3AdgyASBVeAwDMDoSvcDUKoABDICyiT6A1gyAkJqA28aAmgyA0Qy+DoD52oCjEYDqDIB+DDGAQAzmUAAGhfhM4ugAzgDGmCTi+NTFpRClOBAAvGhYeESklAA8AOQAgv0QAD4Q-QBCI+P9AML9AHwA3BDAwBAA2kP9ADQT0-vz-QC6Y1s7RwtH02fj24cTw1en5w97E9dPr-fHR88HH4XL5TD47E7UQr5PIQRYQADiJHwAAlcAxAOYMgC6PQCxUfFAFj-AAt8PhxGUAFzrfCVAkAOgAVmUaWRMABzYBweDAOmEMAgYDmUAQAD6ItFYtFEEAygySsKAZoZAD8MgEmGeyADCjAKaKwvFWqFED55ga6A6OAIxF0vQAKvsANKtc1w1rUKCbc1ndAAD3w6BkZS2FHQADcsBCoCGIAB+LbB0MQMkQK0Qd2e71xx3RiObK37GnZjDG7pmgCiboqABtcNJ0BbrYtFlHozGIH7A5gBSBNdqxRBAGMMgE6GQATDIBGhnlPfbHZFuv5JGw4mZ+AgBogAG8IAWAI64Qgl-ZF0oVOcAXwgADNMGRsBNRAakBUCZuS16WeVgAQSCWyv19SVDRVCGVym0tmoHd0D3Xo1w3EtelzLpTT6HZFn2bZhhOGtdiAt1d3wMD103KDOhNHoKAGYZzlBUiFgQi4AVBF47iosEQVuN4aO+WjmMeP5vjo7YQWopjfkYsFkNQ9DMOwiC8LzWCiLI2YSNmCjEMuQE2N+ajBO4ljlOOTSON4oEeKEsF+OBYyjJQhDRJArDwNw6CCLNBgyDIe8pEozYj03P99nwTBcHQbjfP8-ZPLfAKRKgYDQNsyD7PzPomywdyLLQiEwEFMdO0AQmtXB7LtAGGGQB1hlHMcJ3S8AoDhQBjyMAFW97EAR0VAEhzfEiRJclKWpelGWZNkOWAKQygAdywLkeUqiBavsQBoyLiQliVJClgCpG8uqZVl2QQYAyhcl9KDKag4UAXQZXEANblXEAJqjABkMua2sW5baQZNa2W5Xl+SAA)

**ポイント**

`T extends never ?` のように、 ConditionalType の条件に never を使うと、想定通りの挙動にはならない。
never にはいかなる型も代入できないというエラーになる。

これを回避するためのテクニックとして、 `[T] extends [never]` のように、 never を tuple や array にして評価するテクニックがある。


`K extends K` は一見意味のないもののように見えるが、 Union をループさせるのに有効なテクニック。
K が Union 型の時、 一つずつ順番に loop する。

- [この解説](https://github.com/type-challenges/type-challenges/issues/614) が非常に丁寧。

### [Length of String](https://github.com/type-challenges/type-challenges/issues/359)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBBMCcAcEC0EAyBTAdgcwC4AsIB7AMwgGVcAnASx0mSSeYYCMBPCABRuwgDEAhjggAKAALYkABwA2w9AEoIAYkC0coCxfVbnQBbOYJ1JZNHVUGywDFTYiArmMDyqlagADSrRwrZWPPhcRACwZAGBVADQZACIZAMQZAawZAQAZAcNNAdW1AdCVAK4ZAMYZAS4ZAa4ZAOwZAd1TAVQZAJIZACCjAdO9AdQZAPwZATQZAIAZnCAA+CABxUwAJAFdWQHMGQC6PQFiomsBohkAsf-xcXGkAZwAuYGBcGYBjfAA6ACsZ9aIqbGA4eGBNwTAQYCtQCAB9O-uH+4hAZQZnqMBmhkAfhkBJhiLADCjAKaKt0eIJuEAuVlw7Gk6DQPgIAHkSO46NgADwMcgQdAADx0mAAJjMIDNqKiADQMAAq2LxWCJJLJOAA2gBdCAAXggbLALS5WNx+IZLgAJABvOgkdBUAQAX3FkulEAASrKXAwAPxwnCI5FM9HK8nc9YmqlG-ispoMOYQKnMgDk3h1+HtrKsYGuoJBEDSgE6GQATDIBGhk+vuBXqeEJo+j2uAgUJhEDFEAAogBHLoWI3JnEwlax2UQEhUIi6CD28Tx9BINYWJ3YdAzYBdXA0WQze2Q6GwlaCGYNznchjZ3O4NFpjOyNEYZ1IlE4NH2+1NI0ABiay6HOfQebH6YsU-h+Fn+oXAGsuroaKeiEujQA2deUqDD7ej8f76e+Y8edH2qjoOhBFvCAAFZH03EddwnA8Zz1H8F3IIgukJABCFMumkfAiEwGgL2AgBGB8NzdD0QDDcMwUAQmscl9NJAGGGQB1hnI8NwUuUAGBaQBjyMAFW8ikAR0VAEhzUYJimWYFiWVYNm2XZ9kOBBgGEGYAHdpROM4oC43jAGjI8ZJmmeZFmWNYth2PYDiOYAZiIWRmxobCZg4iBAF0GHJADW5HJACaowAZDJE-TxKMqTTNk05zkuIA)

- 文字列を配列に変換して、 `array['length']` で長さを測る
- そのために Generics の二つ目に `T extends [] = []` を設定する
- `Capitalize` 同様、 `S extends ${infer F}${infer R}` で、一文字目とそれ以外で分割できる
- ↑ で取得した F を Generics で用意した T に突っ込み、最後に `T['length']` で長さを取得する。

### [Flatten](https://github.com/type-challenges/type-challenges/blob/main/questions/00459-medium-flatten/README.ja.md)

- [Answer](https://www.typescriptlang.org/play?ssl=24&ssc=1&pln=24&pc=31#code/PQKgUABBAsCsCcEC0EBiAbAhgF2wUwDtJklSziAjATwgC8ALAewFcqBLAWzYIHMIAKAAIBjehQBOjAJQQAxIFo5QFi+czOPGYqYYrJ0RAVzGB5VS1RAygyA7BkBNUYBkMwOYMgewZAgAyB15UCKDIDXlQMYMgfQZAsomB0JUAkhkBVhkBLhkBhhkAJhkA0ZUB1Bi9AaPUAwC-FQGylQE0GQGiGRMAPs0B5BkBR-UBAyMAZBkAhBkAohkA-BjTAIAZjCEBo+UAJBkAHBgAueoADbuwAZ2JsKgAHPAgAMyxcQggAXjRJ-AIAHgBtAEYAGggAJi2VgGYt6ABdPZWV2GOrgD4IYGAIda3diEOYLcvibs7624BxNjYAASzAoNkAXR6AWKjMoAsf-ouCGvTa9z6ogAdAArXpoxjiHjAODwYAYzBgEDALSgCAAfVpdPpdIgJhMgGsGQDNDIAfhkAkwwBQAYUYBTRRpDOF1Ig5K0gxG8xwiyWAGUIHgAB6LAAmvQgmAIVBWpwgABVFSrCOrNdrdbNHsdbjNiArlWqNStuGM8OIIAANLZon0ut0QACax2IAH5PUbHWadcGoFAwxgZYRVj60V6ICmg1t9ddiFA2tKpssVhm9cWffqth7rcR8-rKSAhSL6RBAGMMgE6GCKARoYOW3G03aWKKZwhrjsBBJaMAN4QACiAEdmJh0FsZ0qRsIxwBfcaSDgQADkggnSFES-QhB4eF6wGY2DY6F6+7AE7QloThdW1ZfwkwvSvlpWYhV3XbAlnnRd0CWd9ZV1a49mtOCgLXPANzAhclyghYkyeHYtjeE44MeTZcNeI4EI2JCQLQiDMMTItiJWbYbj2YimOuRCoGAlDQPAjDoOw1i9nw0tzkuK5rRY548KOD5yMo7jqL4rCi2nMZGEYfN9woVR92efM1gABggTctn3NTGG08R9wkx5VPUzTLN0nZ9KMkyD3Mxy5ODMB7ggI9eiQZUQMCtRcWfYZRjdSR3Tmfjln3NZ9xzHyG37ZtAEJrMw2xbMJAHWGPt+0HFLiFuQBjyMAFW8AkAR0VAEhzWF4WwRFkWAVF6ExbFcXxQlgC1XoAHc3WJUkoDKyrAGjIjI4QRJEUV6dEsRxPECQQYBekYdBbzYRgCH6EaIEAXQYzEANblLCsKbGpmlq5rahbOqGskKSAA)

- Generics の二つ目に、配列を flat にした値を入れるための配列を用意する。(Length of String と同様)
- 再帰的にFlatten を呼ぶ。

### [Append to object](https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-append-to-object/README.md)

- [Answer](https://www.typescriptlang.org/play?#code/PQKgUABBCsBMDsEC0ECCAHdBTAdgEwgBcB7CYgIwCssBjQyZJJ5h8gTzXwCcsOBpLgEMAzsQBuwgNYcAFAAFyPAMwAGSUIBsAThrCAlBADEAWyx4AlgFdjRitTpJJvYWAaH3EAIqWswwueIcVygASWN0ABssUxxCCEEiNmwiAAtBOME8PGF4iBwsAHcIADNzLAiCElSsCHNYrC5iwRosADoIABUUmsIknsEnHMJu1J4awS4Ac2tcQmF2rpriS0J0FYhhFOWKiHJxnDIqWjiC82HqvMKSsorW4IgAMWIuCCwAD0FwqPuAAz+5hi9ZIdXxxAC8EAA3rU8AAuCAAcgAjAiIABfQF9CAAJV8lgi4LQmFweA6xAA8kc6AAeEF+AA0iLEggiPgRjIALAA+CDAYCvN7YOhmIikPZQmHw5HsiDM1lYeEc9EMP4-e48gBqZSKgQgAHEzgAJSzkeEpQirYSwvlzGgpVqUebPSbAODwMAgYCuUAQAD6-oDgYDEAAmssXgBhYh4GqGho1IOJ-0QT2uIE1DDYfBkyn2Qi0xkAVQFhBJOT8XDqk0ZGp5EMhDAA2nxagcnGxiMVOhAAD4QQsAXXhLfepfwOXbne7AH5Os2BxB4RqwBiwD6k4nOqCIBGRL4-RvAymveZws84umJQBRACOlhZjKvguO6JKXGINgRcnTSDtLKiOCTL4wArOYETCAiaZYqWfhIhA9YMO2Uo0OkkFQHKPhSpMYw4JBq6XjBhBPkKhBwQhUBIYiKGEGhsosphiLYVguC0VspjwuQxDEFEghBPh0GgrA8FQohvBSngxCTKifaWPgWClPkeAMBhCqIgUKRnFgtHCLJ8KEFwPgrlBySEcRxxCeRECUQiElSb2ECyTGClmMp9GqQi6madpulEAZWAMGxqlIkZYAEaCSjCQ2FFiVRxAFLRKlSmw5QRHF3k4PCTTgf5-EmaCZl0BFlnWTQaWufKSUpWVUA6RlJQssI-lQMYXF1VljX2Y58l1C5uU1ChjU5BCjYMAV+a3veETUpmJI5lS+aEUijIIoFMqcdxWC8VyjKmc+dBIly22jXt413iy03EtmFLzdShGwMtq2MgdO35SdsCHfSx0kdSE3nTNV25sct3hctLWBDK7U1DJcnOXg21EK9JFKB9YADt6IAHoeyYPJYXDDA0EAAMqlugORY8GqagAwPKE2kPAQB2uMbNxoGBFaEDmpa1rALa9qOq0zquggwC8cIBQNNTEBalcoisv4bNmhapPc7zDpOlMQvwMAsuszgLhQDyACyzw1BGaQRABQHs5zys2sIdpqwLUwel6QA)


- `Type Lookup` であったように、 string に対しても `K in keyof U` が使える。
- `|` を使うことで、順番に展開して評価してくれる。

```ts
type AppendToObject<T, U extends string, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```
